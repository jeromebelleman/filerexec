#! /usr/bin/env python
'''
Remotely execute processes from files
'''

import os
import sys
import time
from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter
import subprocess
import copy
import datetime
import logging
import signal
import yaml
import watchdog.observers
import watchdog.events

class EventHandler(watchdog.events.PatternMatchingEventHandler):
    '''
    Handle events
    '''

    def __init__(self, dry, jobs, previousjobs, procs):
        '''
        Initialise event handler
        '''

        super(EventHandler, self).__init__(patterns=[dry + '/filerexec.yaml'],
                                           ignore_directories=True)
        self.dry = dry
        self.jobs = jobs
        self.previousjobs = previousjobs
        self.procs = procs


    def on_modified(self, event):
        '''
        Manage jobs from file change
        '''

        loadjobs(self.dry, self.jobs, self.previousjobs)
        managejobs(self.jobs, self.procs)


def loadjobs(dry, jobs, previousjobs):
    '''
    Load jobs from file
    '''

    with open(dry + '/filerexec.yaml') as fhl:
        jobs[0] = yaml.load(fhl)
        previousjobs[0] = copy.deepcopy(jobs[0])


def managejobs(jobs, procs):
    '''
    Start or stop jobs
    '''

    for job in jobs[0]:
        try:
            if jobs[0][job]['operation'].lower() == 'start' and \
                job not in procs:
                logging.info("Starting %s", job)
                proc = subprocess.Popen(jobs[0][job]['commands'], shell=True)
                procs[job] = proc
            elif jobs[0][job]['operation'].lower() == 'stop' and \
                job in procs:
                logging.info("Stopping %s", job)
                procs[job].kill()
        except KeyError, exc:
            logging.warning('Missing key for %s: %s', job, exc)


def termhandler(signum, frame): # pylint: disable=unused-argument
    '''
    Handle SIGTERM
    '''

    logging.info("Stopping filerexec")
    sys.exit(0)


def main():
    '''
    Main loop
    '''

    # Parse arguments
    parser = ArgumentParser(description=__doc__,
                            epilog=":set bkc=yes on Windows",
                            formatter_class=ArgumentDefaultsHelpFormatter)
    parser.add_argument('directory', help="path to runtime directory")
    parser.add_argument('--sleep', type=int, help="loop sleep time in seconds",
                        default=60)
    parser.add_argument('--heartbeat', type=int, default=720,
                        help="heartbeat frequency in minutes")
    args = parser.parse_args()

    dry = os.path.abspath(args.directory)

    # Set up logging
    logging.basicConfig(filename=dry + '/filerexec.log',
                        level=logging.INFO,
                        format="%(asctime)s %(levelname)s %(message)s",
                        datefmt='%Y-%m-%d %H-%M')
    logging.info("Starting filerexec: %s", args)

    # Catch SIGTERM
    signal.signal(signal.SIGTERM, termhandler)

    # Load jobs
    procs = {}
    jobs = [{}]
    previousjobs = [{}]
    try:
        loadjobs(dry, jobs, previousjobs)
    except IOError, exc:
        logging.error(exc)
        logging.info("Stopping filerexec")
        return 1
    managejobs(jobs, procs)

    # Set up watchdog
    handler = EventHandler(dry, jobs, previousjobs, procs)
    observer = watchdog.observers.Observer()
    try:
        observer.schedule(handler, dry)
        observer.start()
    except OSError, exc:
        logging.error('%s: %s', dry, exc)
        logging.info("Stopping filerexec")
        return 1

    # Loop
    try:
        heartbeat = datetime.datetime.now()
        while True:
            # Update processes
            toremove = []
            for process in procs:
                polled = procs[process].poll()
                if polled is not None:
                    logging.info("Cleaning up %s which exited %d",
                                 process, polled)
                    jobs[0][process]['operation'] = 'stop'
                    toremove.append(process)
            for process in toremove:
                del procs[process]

            # Update job file
            if jobs != previousjobs:
                with open(dry + '/filerexec.yaml', 'w') as fhl:
                    yaml.dump(jobs[0], fhl, default_flow_style=False, indent=4)
                    previousjobs[0] = copy.deepcopy(jobs[0])

            now = datetime.datetime.now()
            if now - heartbeat > datetime.timedelta(minutes=args.heartbeat):
                logging.info('Heartbeat')
                heartbeat = now

            time.sleep(args.sleep)
    except KeyboardInterrupt:
        observer.stop()
    observer.join()
    logging.info("Stopping filerexec")


if __name__ == '__main__':
    sys.exit(main())
