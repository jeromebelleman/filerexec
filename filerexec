#! /usr/bin/env python
'''
Remotely execute processes from files
'''

import os
import sys
import time
import argparse
import subprocess
import copy
import yaml
import watchdog.observers
import watchdog.events

class EventHandler(watchdog.events.PatternMatchingEventHandler):
    '''
    Handle events
    '''

    def __init__(self, path, jobs, previousjobs, procs):
        '''
        Initialise event handler
        '''

        super(EventHandler, self).__init__(patterns=[path],
                                           ignore_directories=True)
        self.path = path
        self.jobs = jobs
        self.previousjobs = previousjobs
        self.procs = procs


    def on_modified(self, event):
        '''
        Manage jobs from file change
        '''

        loadjobs(self.path, self.jobs, self.previousjobs)
        managejobs(self.jobs, self.procs)


def loadjobs(path, jobs, previousjobs):
    '''
    Load jobs from file
    '''

    with open(path) as fhl:
        jobs[0] = yaml.load(fhl)
        previousjobs[0] = copy.deepcopy(jobs[0])


def managejobs(jobs, procs):
    '''
    Start or stop jobs
    '''

    for job in jobs[0]:
        if jobs[0][job]['operation'].lower() == 'start' and job not in procs:
            print "Starting %s" % job
            proc = subprocess.Popen(jobs[0][job]['commands'], shell=True)
            procs[job] = proc
        elif jobs[0][job]['operation'].lower() == 'stop' and job in procs:
            print "Stopping %s" % job
            procs[job].kill()


def main():
    '''
    Main loop
    '''

    # Parse arguments
    parser = argparse.ArgumentParser(description=__doc__,
                                     epilog=":set bkc=yes on Windows")
    parser.add_argument('path', help="path to job file")
    parser.add_argument('--sleep', type=int, help="loop sleep time in seconds",
                        default=60)
    args = parser.parse_args()

    # Load jobs
    path = os.path.abspath(args.path)
    procs = {}
    jobs = [{}]
    previousjobs = [{}]
    loadjobs(path, jobs, previousjobs)
    managejobs(jobs, procs)

    # Set up watchdog
    handler = EventHandler(path, jobs, previousjobs, procs)
    observer = watchdog.observers.Observer()
    observer.schedule(handler, os.path.dirname(path))
    observer.start()

    # Loop
    try:
        while True:
            # Update processes
            toremove = []
            for process in procs:
                polled = procs[process].poll()
                if polled is not None:
                    print "Cleaning up %s which exited %d" % (process, polled)
                    jobs[0][process]['operation'] = 'stop'
                    toremove.append(process)
            for process in toremove:
                del procs[process]

            # Update job file
            if jobs != previousjobs:
                with open(path, 'w') as fhl:
                    yaml.dump(jobs[0], fhl, default_flow_style=False, indent=4)
                    previousjobs[0] = copy.deepcopy(jobs[0])

            time.sleep(args.sleep)
    except KeyboardInterrupt:
        observer.stop()
    observer.join()


if __name__ == '__main__':
    sys.exit(main())
