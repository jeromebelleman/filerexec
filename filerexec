#! /usr/bin/env python
'''
Remotely execute processes from files
'''

# FIXME Frequent writes

import sys
import time
import argparse
import subprocess
import watchdog.observers
import watchdog.events

IGNORE = [
    r'.*/\..*',
    r'.*/\d+.*',
]

class EventHandler(watchdog.events.RegexMatchingEventHandler):
    '''
    Handle events
    '''

    def __init__(self):
        '''
        Initialise event handler
        '''

        super(EventHandler, self).__init__(ignore_regexes=IGNORE,
                                           ignore_directories=True)
        self.processes = {}


    def on_modified(self, event):
        '''
        Run process from file change
        '''

        if not event.src_path in self.processes:
            print "Starting %s" % event.src_path
            proc = subprocess.Popen(event.src_path, shell=True)
            self.processes[event.src_path] = proc


def main():
    '''
    Main loop
    '''

    # Parse arguments
    parser = argparse.ArgumentParser(description=__doc__,
                                     epilog=":set bkc=yes on Windows")
    parser.add_argument('runtime', help="runtime directory")
    parser.add_argument('--sleep', type=int, help="loop sleep time in seconds",
                        default=60)
    args = parser.parse_args()

    # Set up watchdog
    handler = EventHandler()
    observer = watchdog.observers.Observer()
    observer.schedule(handler, '%s/jobs' % args.runtime, recursive=True)
    observer.start()

    # Loop
    try:
        while True:
            # Kill processes
            try:
                with open('%s/kill' % args.runtime) as fhl:
                    for line in fhl:
                        process = line.strip()
                        if process in handler.processes:
                            print "Killing %s" % process
                            handler.processes[process].kill()
            except IOError:
                pass

            # Clean up processes
            toremove = []
            for process in handler.processes:
                polled = handler.processes[process].poll()
                if polled is not None:
                    print "Cleaning up %s which exited %d" % (process, polled)
                    toremove.append(process)
            for process in toremove:
                del handler.processes[process]

            # Write process file
            with open('%s/processes' % args.runtime, 'w') as fhl:
                for process in handler.processes:
                    print >> fhl, process

            time.sleep(args.sleep)
    except KeyboardInterrupt:
        observer.stop()
    observer.join()


if __name__ == '__main__':
    sys.exit(main())
