#! /usr/bin/env python
'''
Remotely execute processes from files
'''

# FIXME Frequent writes

import sys
import time
import argparse
import subprocess
import watchdog.observers
import watchdog.events

KILL = [
    r'.*kill$',
]

IGNORE = [
    r'.*/\..*',
    r'.*/\d+.*',
]

class StartEventHandler(watchdog.events.RegexMatchingEventHandler):
    '''
    Handle events
    '''

    def __init__(self):
        '''
        Initialise event handler
        '''

        super(StartEventHandler, self).__init__(ignore_regexes=IGNORE,
                                                ignore_directories=True)
        self.processes = {}


    def on_modified(self, event):
        '''
        Run process from file change
        '''

        if not event.src_path in self.processes:
            print "Starting %s" % event.src_path
            proc = subprocess.Popen(event.src_path, shell=True)
            self.processes[event.src_path] = proc


class KillEventHandler(watchdog.events.RegexMatchingEventHandler):
    '''
    Handle events
    '''

    def __init__(self, path, starthandler):
        '''
        Initialise event handler
        '''

        super(KillEventHandler, self).__init__(regexes=KILL,
                                               ignore_directories=True)
        self.path = path
        self.starthandler = starthandler


    def on_modified(self, event):
        '''
        Kill process from file change
        '''

        try:
            with open('%s/kill' % self.path) as fhl:
                for line in fhl:
                    process = line.strip()
                    if process in self.starthandler.processes:
                        print "Killing %s" % process
                        self.starthandler.processes[process].kill()
        except IOError:
            pass


def main():
    '''
    Main loop
    '''

    # Parse arguments
    parser = argparse.ArgumentParser(description=__doc__,
                                     epilog=":set bkc=yes on Windows")
    parser.add_argument('runtime', help="runtime directory")
    parser.add_argument('--sleep', type=int, help="loop sleep time in seconds",
                        default=60)
    args = parser.parse_args()

    # Set up watchdog
    starthandler = StartEventHandler()
    killhandler = KillEventHandler(args.runtime, starthandler)
    observer = watchdog.observers.Observer()
    observer.schedule(starthandler, '%s/jobs' % args.runtime, recursive=True)
    observer.schedule(killhandler, args.runtime)
    observer.start()

    # Loop
    try:
        previousprocesses = {}

        while True:
            # Clean up processes
            toremove = []
            for process in starthandler.processes:
                polled = starthandler.processes[process].poll()
                if polled is not None:
                    print "Cleaning up %s which exited %d" % (process, polled)
                    toremove.append(process)
            for process in toremove:
                del starthandler.processes[process]

            # Write process file
            if starthandler.processes != previousprocesses:
                with open('%s/processes' % args.runtime, 'w') as fhl:
                    for process in starthandler.processes:
                        print >> fhl, process
                previousprocesses = starthandler.processes.copy()

            time.sleep(args.sleep)
    except KeyboardInterrupt:
        observer.stop()
    observer.join()


if __name__ == '__main__':
    sys.exit(main())
